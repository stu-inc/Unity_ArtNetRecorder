<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Parquet</name>
    </assembly>
    <members>
        <member name="M:Thrift.Collections.TCollections.Equals(System.Collections.IEnumerable,System.Collections.IEnumerable)">
            <summary>
                This will return true if the two collections are value-wise the same.
                If the collection contains a collection, the collections will be compared using this method.
            </summary>
        </member>
        <member name="M:Thrift.Collections.TCollections.GetHashCode(System.Collections.IEnumerable)">
            <summary>
                This returns a hashcode based on the value of the enumerable.
            </summary>
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol._lastField">
            <summary>
                Used to keep track of the last field for the current and previous structs, so we can do the delta stuff.
            </summary>
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol._booleanField">
            <summary>
                If we encounter a boolean field begin, save the TField here so it can have the value incorporated.
            </summary>
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol._boolValue">
            <summary>
                If we Read a field header, and it's a boolean field, save the boolean value here so that ReadBool can use it.
            </summary>
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteStructBeginAsync(Thrift.Protocol.Entities.TStruct,System.Threading.CancellationToken)">
            <summary>
                Write a struct begin. This doesn't actually put anything on the wire. We
                use it as an opportunity to put special placeholder markers on the field
                stack so we can get the field id deltas correct.
            </summary>
        </member>
        <member name="T:Thrift.Protocol.TCompactProtocol.Types">
            <summary>
                All of the on-wire exType codes.
            </summary>
        </member>
        <member name="M:Thrift.Protocol.Utilities.TJSONProtocolHelper.IsJsonNumeric(System.Byte)">
            <summary>
                Return true if the given byte could be a valid part of a JSON number.
            </summary>
        </member>
        <member name="M:Thrift.Protocol.Utilities.TJSONProtocolHelper.ToHexVal(System.Byte)">
            <summary>
                Convert a byte containing a hex char ('0'-'9' or 'a'-'f') into its
                corresponding hex value
            </summary>
        </member>
        <member name="M:Thrift.Protocol.Utilities.TJSONProtocolHelper.ToHexChar(System.Byte)">
            <summary>
                Convert a byte containing a hex value to its corresponding hex character
            </summary>
        </member>
        <member name="M:Thrift.Transport.TEndpointTransport.ResetConsumedMessageSize(System.Int64)">
            <summary>
            Resets RemainingMessageSize to the configured maximum 
            </summary>
        </member>
        <member name="M:Thrift.Transport.TEndpointTransport.UpdateKnownMessageSize(System.Int64)">
            <summary>
            Updates RemainingMessageSize to reflect then known real message size (e.g. framed transport).
            Will throw if we already consumed too many bytes or if the new size is larger than allowed.
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:Thrift.Transport.TEndpointTransport.CheckReadBytesAvailable(System.Int64)">
            <summary>
            Throws if there are not enough bytes in the input stream to satisfy a read of numBytes bytes of data
            </summary>
            <param name="numBytes"></param>
        </member>
        <member name="M:Thrift.Transport.TEndpointTransport.CountConsumedMessageBytes(System.Int64)">
            <summary>
            Consumes numBytes from the RemainingMessageSize.
            </summary>
            <param name="numBytes"></param>
        </member>
        <member name="T:Parquet.Attributes.ParquetColumnAttribute">
            <summary>
            Annotates a class property to provide some extra metadata for it.
            </summary>
        </member>
        <member name="M:Parquet.Attributes.ParquetColumnAttribute.#ctor">
            <summary>
            Creates a new instance of the attribute class
            </summary>
        </member>
        <member name="M:Parquet.Attributes.ParquetColumnAttribute.#ctor(System.String)">
            <summary>
            Creates a new instance of the attribute class specifying column name
            </summary>
            <param name="name">Column name</param>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.Name">
            <summary>
            Column name. When undefined a default property name is used which is simply the declared property name on the class.
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.TimeSpanFormat">
            <summary>
            TmeSpanFormat. MilliSeconds or MicroSeconds
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.DateTimeFormat">
            <summary>
            DateTimeFormat. Impala or DateAndTime or Date
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.DecimalPrecision">
            <summary>
            Precision for decimal fields
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.DecimalScale">
            <summary>
            Scale for decimal fields
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.DecimalForceByteArrayEncoding">
            <summary>
            Should this decimal field force byte array encoding?
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.UseListField">
            <summary>
            Should this field be generated as a <see cref="T:Parquet.Data.ListField"/>?
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.ListContainerName">
            <summary>
            Name of the conatiner for the list. Path will be Name.ListContainerName.ListElementName
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.ListElementName">
            <summary>
            Name of the element for the list. Path will be Name.ListContainerName.ListElementName
            </summary>
        </member>
        <member name="T:Parquet.Attributes.ParquetIgnoreAttribute">
            <summary>
            Annotates a class property as a marker to ignore while serializing to parquet file
            </summary>
        </member>
        <member name="T:Parquet.CompressionMethod">
            <summary>
            Parquet compression method
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.None">
            <summary>
            No compression
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Snappy">
            <summary>
            Snappy compression 
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Gzip">
            <summary>
            Gzip compression
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Lzo">
            <summary>
            LZO
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Brotli">
            <summary>
            Brotli
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.LZ4">
            <summary>
            LZ4
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Zstd">
            <summary>
            ZSTD
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Lz4Raw">
            <summary>
            LZ4 raw
            </summary>
        </member>
        <member name="T:Parquet.Data.ArrayView">
            <summary>
            Encapsulate an array and the length of the array used 
            </summary>
        </member>
        <member name="M:Parquet.Data.BasicDataTypeHandler`1.Compare(`0,`0)">
            <summary>
            less than 0 - x &lt; y
            0 - x == y
            greater than 0 - x &gt; y
            </summary>
        </member>
        <member name="T:Parquet.Data.BasicPrimitiveDataTypeHandler`1">
            <summary>
            Handler for built-in data types in .NET
            </summary>
        </member>
        <member name="M:Parquet.Data.Concrete.BooleanDataTypeHandler.ReadSingle(System.IO.BinaryReader,Parquet.Thrift.SchemaElement,System.Int32)">
            <summary>
            Normally bools are packed, which is implemented in <see cref="M:Parquet.Data.Concrete.BooleanDataTypeHandler.Read(System.IO.BinaryReader,Parquet.Thrift.SchemaElement,System.Array,System.Int32)"/>
            </summary>
        </member>
        <member name="T:Parquet.Data.DataColumn">
            <summary>
            The primary low-level structure to hold data for a parqut column.
            Handles internal data composition/decomposition to enrich with custom data Parquet format requires.
            </summary>
        </member>
        <member name="M:Parquet.Data.DataColumn.#ctor(Parquet.Data.DataField,System.Array,System.Int32[])">
            <summary>
            
            </summary>
            <param name="field"></param>
            <param name="data"></param>
            <param name="repetitionLevels"></param>
        </member>
        <member name="M:Parquet.Data.DataColumn.#ctor(Parquet.Data.DataField,System.Array,System.Int32,System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="field"></param>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="repetitionLevels"></param>
        </member>
        <member name="P:Parquet.Data.DataColumn.Data">
            <summary>
            Column data where definition levels are already applied
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.Offset">
            <summary>
            Offset of the array
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.Count">
            <summary>
            Length of the array
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.RepetitionLevels">
            <summary>
            Repetition levels if any.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.Field">
            <summary>
            Data field
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.HasRepetitions">
            <summary>
            When true, this field has repetitions. It doesn't mean that it's an array though. This property simply checks that
            repetition levels are present on this column.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.Statistics">
            <summary>
            Basic statistics for this data column (populated on read)
            </summary>
        </member>
        <member name="M:Parquet.Data.DataColumn.ToString">
            <summary>
            pretty print
            </summary>
        </member>
        <member name="T:Parquet.Data.DataColumnStatistics">
            <summary>
            Basic statistics for data column
            </summary>
        </member>
        <member name="M:Parquet.Data.DataColumnStatistics.#ctor">
            <summary>
            Creates an uninitalised instance of column statistics
            </summary>
        </member>
        <member name="M:Parquet.Data.DataColumnStatistics.#ctor(System.Int64,System.Int64,System.Object,System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumnStatistics.NullCount">
            <summary>
            Number of null values
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumnStatistics.DistinctCount">
            <summary>
            Number of distinct values
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumnStatistics.MinValue">
            <summary>
            Minimum value, casted to CLR type
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumnStatistics.MaxValue">
            <summary>
            Maximum value, casted to CLR type
            </summary>
        </member>
        <member name="T:Parquet.Data.DataType">
            <summary>
            List of supported data types
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Unspecified">
            <summary>
            Type is not specified, shouldn't be used.
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Boolean">
            <summary>
            Boolean
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Byte">
            <summary>
            Byte
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.SignedByte">
            <summary>
            Signed byte data type
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedByte">
            <summary>
            Unsigned byte
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Short">
            <summary>
            Short
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedShort">
            <summary>
            Unsigned short
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Int16">
            <summary>
            16 bit integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedInt16">
            <summary>
            16 bit unsigned integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Int32">
            <summary>
            32 bit integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedInt32">
            <summary>
            32 bit unsigned integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Int64">
            <summary>
            64 bit integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedInt64">
            <summary>
            64 bit unsigned integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Int96">
            <summary>
            96 bit integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.ByteArray">
            <summary>
            Array of bytes
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.String">
            <summary>
            UTF-8 string
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Float">
            <summary>
            Float
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Double">
            <summary>
            Double
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Decimal">
            <summary>
            Decimal
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.DateTimeOffset">
            <summary>
            DateTimeOffset
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Interval">
            <summary>
            Interval
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.TimeSpan">
            <summary>
            TimeSpan
            </summary>
        </member>
        <member name="T:Parquet.Data.DateTimeFormat">
            <summary>
            Choice of representing dates
            </summary>
        </member>
        <member name="F:Parquet.Data.DateTimeFormat.Impala">
            <summary>
            The impala compatible date, which maps to INT96. This is the default datetime representation.
            </summary>
        </member>
        <member name="F:Parquet.Data.DateTimeFormat.DateAndTime">
            <summary>
            This is the default Parquet datetime representation, but not default option for saving which is <see cref="F:Parquet.Data.DateTimeFormat.Impala"/>.
            Stores date and time up to millisecond precision as INT64
            </summary>
        </member>
        <member name="F:Parquet.Data.DateTimeFormat.Date">
            <summary>
            Only stores a date. Time portion is truncated. Internally stored as INT32
            </summary>
        </member>
        <member name="T:Parquet.Data.DecimalFormatDefaults">
            <summary>
            Pre-defined decimal handling default values; providing backwards compatibility prior to v3.9 where these were made configurable.
            </summary>
        </member>
        <member name="F:Parquet.Data.DecimalFormatDefaults.DefaultPrecision">
            <summary>
            The Default Precision value used when not explicitly defined; this is the value used prior to parquet-dotnet v3.9.
            </summary>
        </member>
        <member name="F:Parquet.Data.DecimalFormatDefaults.DefaultScale">
            <summary>
            The Default Scale value used when not explicitly defined; this is the value used prior to parquet-dotnet v3.9.
            </summary>
        </member>
        <member name="M:Parquet.Data.IDataTypeHandler.IsMatch(Parquet.Thrift.SchemaElement,Parquet.ParquetOptions)">
            <summary>
            Called by the library to determine if this data handler can be used in current schema position
            </summary>
            <param name="tse"></param>
            <param name="formatOptions"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.IDataTypeHandler.Read(System.IO.BinaryReader,Parquet.Thrift.SchemaElement,System.Int32)">
            <summary>
            Reads a single value from the current stream position. This shouldn't be used normally, however it's useful when decoding parquet stats.
            </summary>
            <param name="reader">Incoming data</param>
            <param name="tse">Schema element</param>
            <param name="length">Number of bytes to read (type specific). Pass -1 to read the length from incoming stream if you don't know how long the buffer is.</param>
        </member>
        <member name="M:Parquet.Data.IDataTypeHandler.GetArray(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates or rents a native array
            </summary>
            <param name="minCount">Minimum element count. Realistically there could be more elements than you've asked for only when arrays are rented.</param>
            <param name="rent">Rent or create</param>
            <param name="isNullable">Nullable elements or not</param>
            <returns></returns>
        </member>
        <member name="T:Parquet.Data.Rows.DataColumnEnumerator">
            <summary>
            Helps iterating over <see cref="P:Parquet.Data.Rows.DataColumnEnumerator.DataColumn"/> returning either a singular value or an array if the column is repeated.
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.LazyColumnEnumerator.ToEnumeratorList">
            <summary>
            Helper method to get all elements as a list of enumerators
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.LazyColumnEnumerator.ReadWindow">
            <summary>
            Reads current element using repetition and definition levels. Given "current" repetiton level
            skips over the nest level to create a "window" over appropriate nesting level. This creates an illusion of
            nested enumerators so that you can build data structures from honestly flat parquet columns.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Parquet.Data.Rows.Row">
            <summary>
            Represents a tabular row
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Rows.Row"/> class which has only one single column.
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.SingleCell(System.Object)">
            <summary>
            Creates a single cell row. Use this method to avoid overloading confusion.
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Rows.Row"/> class.
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.#ctor(System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Rows.Row"/> class.
            </summary>
        </member>
        <member name="P:Parquet.Data.Rows.Row.Values">
            <summary>
            Raw values
            </summary>
        </member>
        <member name="P:Parquet.Data.Rows.Row.Length">
            <summary>
            Gets the number of values in this row
            </summary>
        </member>
        <member name="P:Parquet.Data.Rows.Row.Item(System.Int32)">
            <summary>
            Gets the row value by index
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetBoolean(System.Int32)">
            <summary>
            Gets the value as boolean
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetInt(System.Int32)">
            <summary>
            Gets the value as integer
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetFloat(System.Int32)">
            <summary>
            Gets the value as float
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetLong(System.Int32)">
            <summary>
            Gets the value as long
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetDouble(System.Int32)">
            <summary>
            Gets the value as double
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetBigInt(System.Int32)">
            <summary>
            Gets the value as big integer
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetByteArray(System.Int32)">
            <summary>
            Gets the value as byte array
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetString(System.Int32)">
            <summary>
            Gets the value as string
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetDateTimeOffset(System.Int32)">
            <summary>
            Gets the value as <see cref="T:System.DateTimeOffset"/>
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.IsNullAt(System.Int32)">
            <summary>
            Returns true if value at column <paramref name="i"/> is NULL.
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.Get``1(System.Int32)">
            <summary>
            Gets the value trying to cast to <typeparamref name="T"/>
            </summary>
            <param name="i">Value index</param>
            <exception cref="T:System.ArgumentException">Cannot cast <typeparamref name="T"/></exception>
        </member>
        <member name="M:Parquet.Data.Rows.Row.ToString">
            <summary>
            Converts to internal format string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Row.ToString(System.String)">
            <summary>
            Convert to string with optional formatting
            </summary>
            <param name="format">jsq - one line single-quote json, default, j - one line json</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.ToString(System.String,System.Int32)">
            <summary>
            Convert to string with optional formatting
            </summary>
            <param name="format">jsq - one line single-quote json, default, j - one line json</param>
            <param name="rowIndex">Optional row index. In case of CSV output, index of 0 prints header row</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.Equals(Parquet.Data.Rows.Row)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.Equals(Parquet.Data.Rows.Row,System.Boolean)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetEnumerator">
            <summary>
            Gets object enumerator
            </summary>
        </member>
        <member name="T:Parquet.Data.Rows.RowValidator">
            <summary>
            Everything is rows!!! Not dealing with dictionaries etc. seems like a brilliant idea!!!
            </summary>
        </member>
        <member name="T:Parquet.Data.Rows.Table">
            <summary>
            Represents a table or table chunk that stores data in row format.
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Table.#ctor(Parquet.Data.Schema)">
            <summary>
            Creates an empty table with specified schema
            </summary>
            <param name="schema">Parquet file schema.</param>
        </member>
        <member name="M:Parquet.Data.Rows.Table.#ctor(Parquet.Data.Field[])">
            <summary>
            Creates an empty table with specified fiels as schema
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Table.#ctor(Parquet.Data.Schema,Parquet.Data.DataColumn[],System.Int64)">
            <summary>
            Creates a table with specified schema
            </summary>
            <param name="schema">Parquet file schema.</param>
            <param name="tableData">Optionally initialise this table with data columns that correspond to the passed <paramref name="schema"/></param>
            <param name="rowCount"></param>
        </member>
        <member name="P:Parquet.Data.Rows.Table.Schema">
            <summary>
            Table schema
            </summary>
        </member>
        <member name="P:Parquet.Data.Rows.Table.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Parquet.Data.Rows.Table.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Parquet.Data.Rows.Table.IsReadOnly">
            <summary>
            
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Add(Parquet.Data.Rows.Row)">
            <summary>
            Adds a new row
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Add(System.Object[])">
            <summary>
            Adds a new row from passed cells
            </summary>
            <param name="rowCells"></param>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Clear">
            <summary>
            /
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Contains(Parquet.Data.Rows.Row)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.CopyTo(Parquet.Data.Rows.Row[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Parquet.Data.Rows.Table.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.IndexOf(Parquet.Data.Rows.Row)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Insert(System.Int32,Parquet.Data.Rows.Row)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Remove(Parquet.Data.Rows.Row)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Equals(Parquet.Data.Rows.Table)">
            <summary>
            Compares tables for equality, including:
            - schema equality
            - row count
            - row values equality
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Equals(Parquet.Data.Rows.Table,System.Boolean)">
            <summary>
            Compares tables for equality, including:
            - schema equality
            - row count
            - row values equality
            </summary>
            <param name="other"></param>
            <param name="throwExceptions"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.ToString">
            <summary>
            Converts table to multiline json. Only shows the first 10 rows as table may be large.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts to string with optional formatting.  Only shows the first 10 rows as table may be large.
            </summary>
            <param name="format">jsq - one line single-quote json, default, j - one line json</param>
            <param name="formatProvider">Optaional format provider, not used at the moment</param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.ToString(System.String)">
            <summary>
            Converts to string with optional formatting.  Only shows the first 10 rows as table may be large.
            </summary>
            <param name="format">jsq - one line single-quote json, default, j - one line json</param>
            <returns></returns>
        </member>
        <member name="T:Parquet.Data.Rows.TableReader">
            <summary>
            Navigates the table
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.TableReader.#ctor(Parquet.Data.Rows.Table)">
            <summary>
            
            </summary>
        </member>
        <member name="T:Parquet.Data.DataField">
            <summary>
            Field containing actual data, unlike fields containing metadata.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.DataType">
            <summary>
            Data type of this element
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.HasNulls">
            <summary>
            When true, this element is allowed to have nulls
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.IsArray">
            <summary>
            When true, the value is an array rather than a single value.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.ClrType">
            <summary>
            CLR type of this column.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.ClrNullableIfHasNullsType">
            <summary>
            Unsupported, use at your own risk!
            </summary>
        </member>
        <member name="M:Parquet.Data.DataField.#ctor(System.String,System.Type)">
            <summary>
            Creates a new instance of <see cref="T:Parquet.Data.DataField"/> by name and CLR type.
            </summary>
            <param name="name">Field name</param>
            <param name="clrType">CLR type of this field. The type is internally discovered and expanded into appropriate Parquet flags.</param>
        </member>
        <member name="M:Parquet.Data.DataField.#ctor(System.String,Parquet.Data.DataType,System.Boolean,System.Boolean,System.String)">
            <summary>
            Creates a new instance of <see cref="T:Parquet.Data.DataField"/> by specifying all the required attributes.
            </summary>
            <param name="name">Field name.</param>
            <param name="dataType">Native Parquet type</param>
            <param name="hasNulls">When true, the field accepts null values. Note that nullable values take slightly more disk space and computing comparing to non-nullable, but are more common.</param>
            <param name="isArray">When true, each value of this field can have multiple values, similar to array in C#.</param>
            <param name="propertyName">When set, uses this property to get the field's data.  When not set, uses the property that matches the name parameter.</param>
        </member>
        <member name="M:Parquet.Data.DataField.PropagateLevels(System.Int32,System.Int32)">
            <summary>
            see
            <see cref="M:Parquet.File.ThriftFooter.GetLevels(Parquet.Thrift.ColumnChunk,System.Int32@,System.Int32@)"/>
            and
            <see cref="M:Parquet.Data.BasicDataTypeHandler`1.CreateSchemaElement(System.Collections.Generic.IList{Parquet.Thrift.SchemaElement},System.Int32@,System.Int32@)"/>
            </summary>
        </member>
        <member name="M:Parquet.Data.DataField.Equals(Parquet.Data.DataField)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Parquet.Data.DataField.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Parquet.Data.DataField.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="T:Parquet.Data.DataField`1">
            <summary>
            Element of dataset's schema. Provides a helper way to construct a schema element with .NET generics.
            <typeparamref name="T">Type of element in the column</typeparamref>
            </summary>
        </member>
        <member name="M:Parquet.Data.DataField`1.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Field"/> class.
            </summary>
            <param name="name">Column name</param>
        </member>
        <member name="T:Parquet.Data.DateTimeDataField">
            <summary>
            Schema element for <see cref="T:System.DateTimeOffset"/> which allows to specify precision
            </summary>
        </member>
        <member name="P:Parquet.Data.DateTimeDataField.DateTimeFormat">
            <summary>
            Desired data format, Parquet specific
            </summary>
        </member>
        <member name="M:Parquet.Data.DateTimeDataField.#ctor(System.String,Parquet.Data.DateTimeFormat,System.Boolean,System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.DateTimeDataField"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="format">The format.</param>
            <param name="hasNulls">Is 'DateTime?'</param>
            <param name="isArray">When true, each value of this field can have multiple values, similar to array in C#.</param>
            <param name="propertyName">When set, uses this property to get the field's data.  When not set, uses the property that matches the name parameter.</param>
        </member>
        <member name="T:Parquet.Data.DecimalDataField">
            <summary>
            Maps to Parquet decimal type, allowing to specify custom scale and precision
            </summary>
        </member>
        <member name="P:Parquet.Data.DecimalDataField.Precision">
            <summary>
            Precision
            </summary>
        </member>
        <member name="P:Parquet.Data.DecimalDataField.Scale">
            <summary>
            Scale
            </summary>
        </member>
        <member name="P:Parquet.Data.DecimalDataField.ForceByteArrayEncoding">
            <summary>
            Gets a flag indicating whether byte array encoding is forced.
            </summary>
        </member>
        <member name="M:Parquet.Data.DecimalDataField.#ctor(System.String,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.String)">
            <summary>
            Constructs class instance
            </summary>
            <param name="name">The name of the column</param>
            <param name="precision">Custom precision</param>
            <param name="scale">Custom scale</param>
            <param name="forceByteArrayEncoding">Whether to force decimal type encoding as fixed bytes. Hive and Impala only understands decimals when forced to true.</param>
            <param name="hasNulls">Is 'decimal?'</param>
            <param name="isArray">Indicates whether this field is repeatable.</param>
            <param name="propertyName">When set, uses this property to get the field's data.  When not set, uses the property that matches the name parameter.</param>
        </member>
        <member name="T:Parquet.Data.Field">
            <summary>
            Element of dataset's schema
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.SchemaType">
            <summary>
            Type of schema in this field
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.Name">
            <summary>
            Column name
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.Path">
            <summary>
            Gets Parquet column path. For non-nested columns always equals to column <see cref="P:Parquet.Data.Field.Name"/> otherwise contains
            a dot (.) separated path to the column within Parquet file. Note that this is a physical path which depends on field
            schema and you shouldn't build any reasonable business logic based on it.
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.MaxRepetitionLevel">
            <summary>
            Max repetition level
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.MaxDefinitionLevel">
            <summary>
            Max definition level
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.ClrPropName">
            <summary>
            Used internally for serialisation
            </summary>
        </member>
        <member name="M:Parquet.Data.Field.#ctor(System.String,Parquet.Data.SchemaType)">
            <summary>
            Constructs a field with only requiremd parameters
            </summary>
            <param name="name">Field name, required</param>
            <param name="schemaType">Type of schema of this field</param>
        </member>
        <member name="M:Parquet.Data.Field.PropagateLevels(System.Int32,System.Int32)">
            <summary>
            Called by schema when field hierarchy is constructed, so that fields can calculate levels as this is
            done in reverse order of construction and needs to be done after data is ready
            </summary>
        </member>
        <member name="M:Parquet.Data.Field.ToString">
            <summary>
            pretty prints
            </summary>
        </member>
        <member name="T:Parquet.Data.ListField">
            <summary>
            Represents a list of items. The list can contain either a normal data field or a complex structure.
            If you need to get a list of primitive data fields it's more efficient to use arrays.
            </summary>
        </member>
        <member name="F:Parquet.Data.ListField.DefaultContainerName">
            <summary>
            Default container name for a list
            </summary>
        </member>
        <member name="P:Parquet.Data.ListField.Item">
            <summary>
            Item contained within this list
            </summary>
        </member>
        <member name="M:Parquet.Data.ListField.#ctor(System.String,Parquet.Data.Field,System.String)">
            <summary>
            Creates a new instance of <see cref="T:Parquet.Data.ListField"/>
            </summary>
            <param name="name">Field name</param>
            <param name="item">Field representing list element</param>
            <param name="containerName">Container name</param>
        </member>
        <member name="M:Parquet.Data.ListField.#ctor(System.String,Parquet.Data.DataType,System.Boolean,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of <see cref="T:Parquet.Data.ListField"/>
            </summary>
            <param name="name">Field name</param>
            <param name="dataType">Native Parquet type</param>
            <param name="hasNulls">When true, the field accepts null values. Note that nullable values take slightly more disk space and computing comparing to non-nullable, but are more common.</param>
            <param name="propertyName">When set, uses this property to get the list's data.  When not set, uses the property that matches the name parameter.</param>
            <param name="containerName">Container name</param>
            <param name="elementName">Element name</param>
        </member>
        <member name="M:Parquet.Data.ListField.Equals(Parquet.Data.ListField)">
            <summary>
            </summary>
        </member>
        <member name="M:Parquet.Data.ListField.Equals(System.Object)">
            <summary>
            </summary>
        </member>
        <member name="M:Parquet.Data.ListField.GetHashCode">
            <summary>
            </summary>
        </member>
        <member name="T:Parquet.Data.MapField">
            <summary>
            Implements a dictionary field
            </summary>
        </member>
        <member name="P:Parquet.Data.MapField.Key">
            <summary>
            Data field used as a key
            </summary>
        </member>
        <member name="P:Parquet.Data.MapField.Value">
            <summary>
            Data field used as a value
            </summary>
        </member>
        <member name="M:Parquet.Data.MapField.#ctor(System.String,Parquet.Data.DataField,Parquet.Data.DataField)">
            <summary>
            Declares a map field
            </summary>
        </member>
        <member name="M:Parquet.Data.MapField.CreateSimpleDictionary">
            <summary>
            Creates an empty dictionary to keep values for this map field. Only works when both key and value are <see cref="T:Parquet.Data.DataField"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.MapField.Equals(System.Object)">
            <summary>
            <see cref="M:Parquet.Data.MapField.Equals(System.Object)"/>
            </summary>
        </member>
        <member name="M:Parquet.Data.MapField.GetHashCode">
            <summary>
            <see cref="M:Parquet.Data.MapField.GetHashCode"/>
            </summary>
        </member>
        <member name="T:Parquet.Data.Schema">
            <summary>
            Represents dataset schema
            </summary>
        </member>
        <member name="F:Parquet.Data.Schema.PathSeparator">
            <summary>
            Symbol used to separate path parts in schema element path
            </summary>
        </member>
        <member name="F:Parquet.Data.Schema.PathSeparatorChar">
            <summary>
            Character used to separate path parts in schema element path
            </summary>
        </member>
        <member name="M:Parquet.Data.Schema.#ctor(System.Collections.Generic.IReadOnlyCollection{Parquet.Data.Field})">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Schema"/> class from schema elements.
            </summary>
            <param name="fields">The elements.</param>
        </member>
        <member name="M:Parquet.Data.Schema.#ctor(Parquet.Data.Field[])">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Schema"/> class.
            </summary>
            <param name="fields">The elements.</param>
        </member>
        <member name="P:Parquet.Data.Schema.Fields">
            <summary>
            Gets the schema elements
            </summary>
        </member>
        <member name="P:Parquet.Data.Schema.Item(System.Int32)">
            <summary>
            Get schema element by index
            </summary>
            <param name="i">Index of schema element</param>
            <returns>Schema element</returns>
        </member>
        <member name="M:Parquet.Data.Schema.GetDataFields">
            <summary>
            Gets a flat list of all data fields in this schema
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Schema.Equals(Parquet.Data.Schema)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Parquet.Data.Schema.GetNotEqualsMessage(Parquet.Data.Schema,System.String,System.String)">
            <summary>
            Compares this schema to <paramref name="other"/> and produces a human readable message describing the differences.
            </summary>
        </member>
        <member name="M:Parquet.Data.Schema.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Parquet.Data.Schema.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Parquet.Data.Schema.ToString">
            <summary>
            </summary>
        </member>
        <member name="T:Parquet.Data.StructField">
            <summary>
            Represents a structure i.e. a container for other fields.
            </summary>
        </member>
        <member name="M:Parquet.Data.StructField.#ctor(System.String,Parquet.Data.Field[])">
            <summary>
            Creates a new structure field 
            </summary>
            <param name="name">Structure name</param>
            <param name="elements">List of elements</param>
        </member>
        <member name="P:Parquet.Data.StructField.Fields">
            <summary>
            Elements of this structure
            </summary>
        </member>
        <member name="M:Parquet.Data.StructField.Equals(Parquet.Data.StructField)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.StructField.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.StructField.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Parquet.Data.TimeSpanDataField">
            <summary>
            Schema element for <see cref="T:System.TimeSpan"/> which allows to specify precision
            </summary>
        </member>
        <member name="P:Parquet.Data.TimeSpanDataField.TimeSpanFormat">
            <summary>
            Desired data format, Parquet specific
            </summary>
        </member>
        <member name="M:Parquet.Data.TimeSpanDataField.#ctor(System.String,Parquet.Data.TimeSpanFormat,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.TimeSpanDataField"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="format">The format.</param>
            <param name="hasNulls">Is 'TimeSpan?'</param>
            <param name="isArray"></param>
        </member>
        <member name="T:Parquet.Data.SchemaType">
            <summary>
            Type of schema
            </summary>
        </member>
        <member name="F:Parquet.Data.SchemaType.Data">
            <summary>
            Contains actual values i.e. declared by a <see cref="T:Parquet.Data.DataField"/>
            </summary>
        </member>
        <member name="F:Parquet.Data.SchemaType.Map">
            <summary>
            Contains dictionary definition
            </summary>
        </member>
        <member name="F:Parquet.Data.SchemaType.Struct">
            <summary>
            Contains structure definition
            </summary>
        </member>
        <member name="F:Parquet.Data.SchemaType.List">
            <summary>
            Contains list definition
            </summary>
        </member>
        <member name="T:Parquet.Data.TimeSpanFormat">
            <summary>
            Choice of representing time
            </summary>
        </member>
        <member name="F:Parquet.Data.TimeSpanFormat.MilliSeconds">
            <summary>
            A time
            
            The total number of milliseconds since midnight.  The value is stored
            as an INT32 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Data.TimeSpanFormat.MicroSeconds">
            <summary>
            A time.
            
            The total number of microseconds since midnight.  The value is stored as
            an INT64 physical type.
            </summary>
        </member>
        <member name="M:Parquet.CollectionExtensions.Batch``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Batch through IEnumerable without going to the beginning every time. May need optimisations but OK so far.
            </summary>
        </member>
        <member name="T:Parquet.ThriftExtensions">
            <summary>
            Internal thrift data structure helpers
            </summary>
        </member>
        <member name="M:Parquet.TypeExtensions.CreateGenericList(System.Type)">
            <summary>
            Creates a generic typed list of elements of this type.
            </summary>
        </member>
        <member name="M:Parquet.TypeExtensions.TryExtractEnumerableType(System.Type,System.Type@)">
            <summary>
            Checks if this type implements generic IEnumerable or an array.
            </summary>
            <param name="t"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="T:Parquet.File.StringListComparer">
            <summary>
            Wraps a list of strings and provides equality 
            </summary>
        </member>
        <member name="T:Parquet.File.ThriftStream">
            <summary>
            Utility methods to work with Thrift data in a stream
            </summary>
        </member>
        <member name="M:Parquet.File.ThriftStream.ReadAsync``1(System.Threading.CancellationToken)">
            <summary>
            Reads typed structure from incoming stream
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Parquet.File.ThriftStream.WriteAsync``1(``0,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Writes types structure to the destination stream
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <param name="rewind">When true, rewinds to the original position before writing</param>
            <param name="cancellationToken"></param>
            <returns>Actual size of the object written</returns>
        </member>
        <member name="T:Parquet.File.Values.Primitives.BigDecimal">
            <summary>
            A class that encapsulates BigDecimal like the java class
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.BigDecimal.DecimalValue">
            <summary>
            Contains a Decimal value that is the big integer
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.BigDecimal.Scale">
            <summary>
            The scale of the decimal value
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.BigDecimal.Precision">
            <summary>
            The precision of the decimal value
            </summary>
        </member>
        <member name="M:Parquet.File.Values.Primitives.BigDecimal.op_Implicit(Parquet.File.Values.Primitives.BigDecimal)~System.Decimal">
            <summary>
            Converts a BigDecimal to a decimal
            </summary>
            <param name="bd">The BigDecimal value</param>
        </member>
        <member name="M:Parquet.File.Values.Primitives.BigDecimal.GetBufferSize(System.Int32)">
            <summary>
            Gets buffer size enough to be able to hold the decimal number of a specific precision
            </summary>
            <param name="precision">Precision value</param>
            <returns>Length in bytes</returns>
        </member>
        <member name="T:Parquet.File.Values.Primitives.Interval">
            <summary>
            A parquet interval type compatible with a Spark INTERVAL type
            12 byte little Endian structure fits in an INT96 original type with an INTERVAL converted type
            </summary>
        </member>
        <member name="M:Parquet.File.Values.Primitives.Interval.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Used to create an interval type
            </summary>
            <param name="months">The month interval</param>
            <param name="days">The days interval</param>
            <param name="millis">The milliseconds interval</param>
        </member>
        <member name="P:Parquet.File.Values.Primitives.Interval.Millis">
            <summary>
            Returns the number of milliseconds in the type
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.Interval.Days">
            <summary>
            Returns the number of days in the type
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.Interval.Months">
            <summary>
            Returns the number of months in type
            </summary>
        </member>
        <member name="M:Parquet.File.Values.RunLengthBitPackingHybridValuesReader.ReadRle(System.Int32,System.IO.BinaryReader,System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Read run-length encoded run from the given header and bit length.
            </summary>
        </member>
        <member name="M:Parquet.File.Values.RunLengthBitPackingHybridValuesReader.ReadUnsignedVarInt(System.IO.BinaryReader)">
            <summary>
            Read a value using the unsigned, variable int encoding.
            </summary>
        </member>
        <member name="M:Parquet.File.Values.RunLengthBitPackingHybridValuesWriter.WriteForwardOnly(System.IO.BinaryWriter,System.Int32,System.Int32[],System.Int32)">
            <summary>
            Writes to target stream without jumping around, therefore can be used in forward-only stream
            </summary>
        </member>
        <member name="T:Parquet.ParquetActor">
            <summary>
            Base class for reader and writer
            </summary>
        </member>
        <member name="P:Parquet.ParquetActor.Stream">
            <summary>
            Original stream to write or read
            </summary>
        </member>
        <member name="T:Parquet.ParquetConvert">
            <summary>
            High-level object oriented API for Apache Parquet
            </summary>
        </member>
        <member name="M:Parquet.ParquetConvert.SerializeAsync``1(System.Collections.Generic.IEnumerable{``0},System.IO.Stream,Parquet.Data.Schema,Parquet.CompressionMethod,System.Int32,System.Boolean)">
            <summary>
            Serialises a collection of classes into a Parquet stream
            </summary>
            <typeparam name="T">Class type</typeparam>
            <param name="objectInstances">Collection of classes</param>
            <param name="destination">Destination stream</param>
            <param name="schema">Optional schema to use. When not specified the class schema will be discovered and everything possible will be
            written to the stream. If you want to write only a subset of class properties please specify the schema yourself.
            </param>
            <param name="compressionMethod"><see cref="T:Parquet.CompressionMethod"/></param>
            <param name="rowGroupSize"></param>
            <param name="append"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetConvert.SerializeAsync``1(System.Collections.Generic.IEnumerable{``0},System.String,Parquet.Data.Schema,Parquet.CompressionMethod,System.Int32,System.Boolean)">
            <summary>
            Serialises a collection of classes into a Parquet file
            </summary>
            <typeparam name="T">Class type</typeparam>
            <param name="objectInstances">Collection of classes</param>
            <param name="filePath">Destination file path</param>
            <param name="schema">Optional schema to use. When not specified the class schema will be discovered and everything possible will be
            written to the stream. If you want to write only a subset of class properties please specify the schema yourself.
            </param>
            <param name="compressionMethod"><see cref="T:Parquet.CompressionMethod"/></param>
            <param name="rowGroupSize"></param>
            <param name="append"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetConvert.DeserializeAsync``1(System.IO.Stream,System.Int32)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <param name="rowGroupIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetConvert.DeserializeGroupsAsync``1(System.IO.Stream)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:Parquet.ParquetException">
            <summary>
            Parquet format specific
            </summary>
        </member>
        <member name="M:Parquet.ParquetException.#ctor">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="M:Parquet.ParquetException.#ctor(System.String)">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="M:Parquet.ParquetException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="T:Parquet.ParquetExtensions">
            <summary>
            Defines extension methods to simplify Parquet usage (experimental v3)
            </summary>
        </member>
        <member name="M:Parquet.ParquetExtensions.WriteSingleRowGroupParquetFileAsync(System.IO.Stream,Parquet.Data.Schema,Parquet.Data.DataColumn[])">
            <summary>
            Writes a file with a single row group
            </summary>
        </member>
        <member name="M:Parquet.ParquetExtensions.ReadSingleRowGroupParquetFile(System.IO.Stream)">
            <summary>
            Reads the first row group from a file
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Parquet.ParquetExtensions.WriteAsync(Parquet.ParquetWriter,Parquet.Data.Rows.Table)">
            <summary>
            Writes entire table in a single row group
            </summary>
            <param name="writer"></param>
            <param name="table"></param>
        </member>
        <member name="M:Parquet.ParquetExtensions.ReadAsTableAsync(Parquet.ParquetReader)">
            <summary>
            Reads the first row group as a table
            </summary>
            <param name="reader">Open reader</param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetExtensions.WriteAsync(Parquet.ParquetRowGroupWriter,Parquet.Data.Rows.Table)">
            <summary>
            Writes table to this row group
            </summary>
            <param name="writer"></param>
            <param name="table"></param>
        </member>
        <member name="M:Parquet.ParquetExtensions.DecodeSingleStatsValue(Parquet.Thrift.FileMetaData,Parquet.Thrift.ColumnChunk,System.Byte[])">
            <summary>
            Decodes raw bytes from <see cref="T:Parquet.Thrift.Statistics"/> into a CLR value
            </summary>
        </member>
        <member name="T:Parquet.ParquetOptions">
            <summary>
            Parquet options
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.TreatByteArrayAsString">
            <summary>
            When true byte arrays will be treated as UTF-8 strings
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.TreatBigIntegersAsDates">
            <summary>
            Gets or sets a value indicating whether big integers are always treated as dates
            </summary>
        </member>
        <member name="T:Parquet.ParquetReader">
            <summary>
            Implements Apache Parquet format reader, experimental version for next major release.
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.CreateAsync(System.String,Parquet.ParquetOptions,System.Threading.CancellationToken)">
            <summary>
            Opens reader from a file on disk. When the reader is disposed the file handle is automatically closed.
            </summary>
            <param name="filePath"></param>
            <param name="parquetOptions"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetReader.CreateAsync(System.IO.Stream,Parquet.ParquetOptions,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates an instance from input stream
            </summary>
            <param name="input">Input stream, must be readable and seekable</param>
            <param name="parquetOptions">Optional reader options</param>
            <param name="leaveStreamOpen">When true, leaves the stream passed in <paramref name="input"/> open after disposing the reader.</param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.ArgumentNullException">input</exception>
            <exception cref="T:System.ArgumentException">stream must be readable and seekable - input</exception>
            <exception cref="T:System.IO.IOException">not a Parquet file (size too small)</exception>
        </member>
        <member name="P:Parquet.ParquetReader.CustomMetadata">
            <summary>
            Gets custom key-value pairs for metadata
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.ReadTableFromFileAsync(System.String,Parquet.ParquetOptions)">
            <summary>
            Reads entire file as a table
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.ReadTableFromStreamAsync(System.IO.Stream,Parquet.ParquetOptions)">
            <summary>
            Reads entire stream as a table
            </summary>
        </member>
        <member name="P:Parquet.ParquetReader.RowGroupCount">
            <summary>
            Gets the number of rows groups in this file
            </summary>
        </member>
        <member name="P:Parquet.ParquetReader.Schema">
            <summary>
            Reader schema
            </summary>
        </member>
        <member name="P:Parquet.ParquetReader.ThriftMetadata">
            <summary>
            Internal parquet metadata
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.OpenRowGroupReader(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetReader.ReadEntireRowGroupAsync(System.Int32)">
            <summary>
            Reads entire row group's data columns in one go.
            </summary>
            <param name="rowGroupIndex">Index of the row group. Default to the first row group if not specified.</param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetReader.Dispose">
            <summary>
            Disposes 
            </summary>
        </member>
        <member name="T:Parquet.ParquetRowGroupReader">
            <summary>
            Reader for Parquet row groups
            </summary>
        </member>
        <member name="P:Parquet.ParquetRowGroupReader.RowCount">
            <summary>
            Gets the number of rows in this row group
            </summary>
        </member>
        <member name="M:Parquet.ParquetRowGroupReader.ReadColumnAsync(Parquet.Data.DataField,System.Threading.CancellationToken)">
            <summary>
            Reads a column from this row group.
            </summary>
            <param name="field"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetRowGroupReader.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:Parquet.ParquetRowGroupWriter">
            <summary>
            Writer for Parquet row groups
            </summary>
        </member>
        <member name="M:Parquet.ParquetRowGroupWriter.WriteColumnAsync(Parquet.Data.DataColumn,System.Threading.CancellationToken)">
            <summary>
            Writes next data column to parquet stream. Note that columns must be written in the order they are declared in the
            file schema.
            </summary>
            <param name="column"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Parquet.ParquetRowGroupWriter.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:Parquet.ParquetWriter">
            <summary>
            Implements Apache Parquet format writer
            </summary>
        </member>
        <member name="P:Parquet.ParquetWriter.CompressionMethod">
            <summary>
            Type of compression to use, defaults to <see cref="F:Parquet.CompressionMethod.Snappy"/>
            </summary>
        </member>
        <member name="M:Parquet.ParquetWriter.CreateAsync(Parquet.Data.Schema,System.IO.Stream,Parquet.ParquetOptions,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates an instance of parquet writer on top of a stream
            </summary>
            <param name="schema"></param>
            <param name="output">Writeable, seekable stream</param>
            <param name="formatOptions">Additional options</param>
            <param name="append"></param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.ArgumentNullException">Output is null.</exception>
            <exception cref="T:System.ArgumentException">Output stream is not writeable</exception>
        </member>
        <member name="M:Parquet.ParquetWriter.CreateRowGroup">
            <summary>
            Creates a new row group and a writer for it.
            </summary>
        </member>
        <member name="P:Parquet.ParquetWriter.CustomMetadata">
            <summary>
            Gets custom key-value pairs for metadata
            </summary>
        </member>
        <member name="M:Parquet.ParquetWriter.Dispose">
            <summary>
            Disposes the writer and writes the file footer.
            </summary>
        </member>
        <member name="M:Parquet.Serialization.HttpEncoder.JavaScriptStringEncode(System.String)">
            <summary>Encodes a string.</summary>
            <param name="value">The string to encode.</param>
            <returns>An encoded string.</returns>
        </member>
        <member name="T:Parquet.Serialization.ILExtensions">
            <summary>
            Extension methods to simplify MSIL generation
            </summary>
        </member>
        <member name="M:Parquet.Serialization.ILExtensions.CallVirt(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo,System.Object[])">
            <summary>
            
            </summary>
            <param name="il"></param>
            <param name="method"></param>
            <param name="parameters">List of parameters, OpCode and LocalBuilder are supported</param>
        </member>
        <member name="T:Parquet.Serialization.SchemaReflector">
            <summary>
            Infers a class schema using reflection
            </summary>
        </member>
        <member name="M:Parquet.Serialization.SchemaReflector.#ctor(System.Type)">
            <summary>
            </summary>
        </member>
        <member name="M:Parquet.Serialization.SchemaReflector.Reflect">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Serialization.SchemaReflector.Reflect``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Parquet.Serialization.SchemaReflector.Reflect(System.Type)">
            <summary>
            
            </summary>
            <param name="classType"></param>
            <returns></returns>
        </member>
        <member name="T:Parquet.Serialization.Values.ConversionHelpers">
            <summary>
            This class is public to simplify use from Reflection
            </summary>
        </member>
        <member name="M:Parquet.Serialization.Values.ConversionHelpers.DateTimeFromDateTimeOffset(System.DateTimeOffset)">
            <summary>
            Convert DateTimeOffset to DateTime
            </summary>
            <param name="value">DateTimeOffset</param>
            <returns>DateTime</returns>
        </member>
        <member name="M:Parquet.Serialization.Values.ConversionHelpers.NullableDateTimeFromDateTimeOffset(System.Nullable{System.DateTimeOffset})">
            <summary>
            Convert DateTimeOffset? to DateTime?
            </summary>
            <param name="value">DateTimeOffset?</param>
            <returns>DateTime?</returns>
        </member>
        <member name="M:Parquet.Serialization.Values.ConversionHelpers.NullableDateTimeOffsetFromDateTime(System.Nullable{System.DateTime})">
            <summary>
            Convert DateTime? to DateTimeOffset?
            </summary>
            <param name="value">DateTime?</param>
            <returns>DateTimeOffset?</returns>
        </member>
        <member name="M:Parquet.Serialization.Values.ConversionHelpers.NullableBooleanToBooleanConversion(System.Nullable{System.Boolean})">
            <summary>
            Convert Boolean? to Boolean
            </summary>
            <param name="value">Boolean?</param>
            <returns>Boolean</returns>
        </member>
        <member name="P:Parquet.Thrift.AesGcmCtrV1.Aad_prefix">
            <summary>
            AAD prefix *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.AesGcmCtrV1.Aad_file_unique">
            <summary>
            Unique file identifier part of AAD suffix *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.AesGcmCtrV1.Supply_aad_prefix">
            <summary>
            In files encrypted with AAD prefix without storing it,
            readers must supply the prefix *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.AesGcmV1.Aad_prefix">
            <summary>
            AAD prefix *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.AesGcmV1.Aad_file_unique">
            <summary>
            Unique file identifier part of AAD suffix *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.AesGcmV1.Supply_aad_prefix">
            <summary>
            In files encrypted with AAD prefix without storing it,
            readers must supply the prefix *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.BloomFilterAlgorithm">
            <summary>
            The algorithm used in Bloom filter. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.BloomFilterAlgorithm.BLOCK">
            <summary>
            Block-based Bloom filter. *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.BloomFilterHash">
            <summary>
            The hash function used in Bloom filter. This function takes the hash of a column value
            using plain encoding.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.BloomFilterHash.XXHASH">
            <summary>
            xxHash Strategy. *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.BloomFilterHeader">
            <summary>
            Bloom filter header is stored at beginning of Bloom filter data of each column
            and followed by its bitset.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.BloomFilterHeader.NumBytes">
            <summary>
            The size of bitset in bytes *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.BloomFilterHeader.Algorithm">
            <summary>
            The algorithm for setting bits. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.BloomFilterHeader.Hash">
            <summary>
            The hash function used for Bloom filter. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.BloomFilterHeader.Compression">
            <summary>
            The compression used in the Bloom filter *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.BoundaryOrder">
            <summary>
            Enum to annotate whether lists of min/max elements inside ColumnIndex
            are ordered and if so, in which direction.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.BsonType">
            <summary>
            Embedded BSON logical type annotation
            
            Allowed for physical types: BINARY
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.File_path">
            <summary>
            File where column data is stored.  If not set, assumed to be same file as
            metadata.  This path is relative to the current file.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.File_offset">
            <summary>
            Byte offset in file_path to the ColumnMetaData *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Meta_data">
            <summary>
            Column metadata for this chunk. This is the same content as what is at
            file_path/file_offset.  Having it here has it replicated in the file
            metadata.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Offset_index_offset">
            <summary>
            File offset of ColumnChunk's OffsetIndex *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Offset_index_length">
            <summary>
            Size of ColumnChunk's OffsetIndex, in bytes *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Column_index_offset">
            <summary>
            File offset of ColumnChunk's ColumnIndex *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Column_index_length">
            <summary>
            Size of ColumnChunk's ColumnIndex, in bytes *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Crypto_metadata">
            <summary>
            Crypto metadata of encrypted columns *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Encrypted_column_metadata">
            <summary>
            Encrypted column metadata for this chunk *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.ColumnIndex">
            <summary>
            Description for ColumnIndex.
            Each &lt;array-field&gt;[i] refers to the page at OffsetIndex.page_locations[i]
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnIndex.Null_pages">
            <summary>
            A list of Boolean values to determine the validity of the corresponding
            min and max values. If true, a page contains only null values, and writers
            have to set the corresponding entries in min_values and max_values to
            byte[0], so that all lists have the same length. If false, the
            corresponding entries in min_values and max_values must be valid.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnIndex.Min_values">
            <summary>
            Two lists containing lower and upper bounds for the values of each page
            determined by the ColumnOrder of the column. These may be the actual
            minimum and maximum values found on a page, but can also be (more compact)
            values that do not exist on a page. For example, instead of storing ""Blart
            Versenwald III", a writer may set min_values[i]="B", max_values[i]="C".
            Such more compact values must still be valid values within the column's
            logical type. Readers must make sure that list entries are populated before
            using them by inspecting null_pages.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnIndex.Boundary_order">
            <summary>
            Stores whether both min_values and max_values are orderd and if so, in
            which direction. This allows readers to perform binary searches in both
            lists. Readers cannot assume that max_values[i] &lt;= min_values[i+1], even
            if the lists are ordered.
            
            <seealso cref="T:Parquet.Thrift.BoundaryOrder"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnIndex.Null_counts">
            <summary>
            A list containing the number of null values for each page *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.ColumnMetaData">
            <summary>
            Description for column metadata
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Type">
            <summary>
            Type of this column *
            
            <seealso cref="T:Parquet.Thrift.Type"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Encodings">
            <summary>
            Set of all encodings used for this column. The purpose is to validate
            whether we can decode those pages. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Path_in_schema">
            <summary>
            Path in schema *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Codec">
            <summary>
            Compression codec *
            
            <seealso cref="T:Parquet.Thrift.CompressionCodec"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Num_values">
            <summary>
            Number of values in this column *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Total_uncompressed_size">
            <summary>
            total byte size of all uncompressed pages in this column chunk (including the headers) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Total_compressed_size">
            <summary>
            total byte size of all compressed, and potentially encrypted, pages
            in this column chunk (including the headers) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Key_value_metadata">
            <summary>
            Optional key/value metadata *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Data_page_offset">
            <summary>
            Byte offset from beginning of file to first data page *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Index_page_offset">
            <summary>
            Byte offset from beginning of file to root index page *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Dictionary_page_offset">
            <summary>
            Byte offset from the beginning of file to first (only) dictionary page *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Statistics">
            <summary>
            optional statistics for this column chunk
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Encoding_stats">
            <summary>
            Set of all encodings used for pages in this column chunk.
            This information can be used to determine if all data pages are
            dictionary encoded for example *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Bloom_filter_offset">
            <summary>
            Byte offset from beginning of file to Bloom filter data. *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.ColumnOrder">
            <summary>
            Union to specify the order used for the min_value and max_value fields for a
            column. This union takes the role of an enhanced enum that allows rich
            elements (which will be needed for a collation-based ordering in the future).
            
            Possible values are:
            * TypeDefinedOrder - the column uses the order defined by its logical or
                                 physical type (if there is no logical type).
            
            If the reader does not support the value of this union, min and max stats
            for this column should be ignored.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnOrder.TYPE_ORDER">
            <summary>
            The sort orders for logical types are:
              UTF8 - unsigned byte-wise comparison
              INT8 - signed comparison
              INT16 - signed comparison
              INT32 - signed comparison
              INT64 - signed comparison
              UINT8 - unsigned comparison
              UINT16 - unsigned comparison
              UINT32 - unsigned comparison
              UINT64 - unsigned comparison
              DECIMAL - signed comparison of the represented value
              DATE - signed comparison
              TIME_MILLIS - signed comparison
              TIME_MICROS - signed comparison
              TIMESTAMP_MILLIS - signed comparison
              TIMESTAMP_MICROS - signed comparison
              INTERVAL - unsigned comparison
              JSON - unsigned byte-wise comparison
              BSON - unsigned byte-wise comparison
              ENUM - unsigned byte-wise comparison
              LIST - undefined
              MAP - undefined
            
            In the absence of logical types, the sort order is determined by the physical type:
              BOOLEAN - false, true
              INT32 - signed comparison
              INT64 - signed comparison
              INT96 (only used for legacy timestamps) - undefined
              FLOAT - signed comparison of the represented value (*)
              DOUBLE - signed comparison of the represented value (*)
              BYTE_ARRAY - unsigned byte-wise comparison
              FIXED_LEN_BYTE_ARRAY - unsigned byte-wise comparison
            
            (*) Because the sorting order is not specified properly for floating
                point values (relations vs. total ordering) the following
                compatibility rules should be applied when reading statistics:
                - If the min is a NaN, it should be ignored.
                - If the max is a NaN, it should be ignored.
                - If the min is +0, the row group may contain -0 values as well.
                - If the max is -0, the row group may contain +0 values as well.
                - When looking for NaN values, min and max should be ignored.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.CompressionCodec">
            <summary>
            Supported compression algorithms.
            
            Codecs added in format version X.Y can be read by readers based on X.Y and later.
            Codec support may vary between readers based on the format version and
            libraries available at runtime.
            
            See Compression.md for a detailed specification of these algorithms.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.ConvertedType">
            <summary>
            DEPRECATED: Common types used by frameworks(e.g. hive, pig) using parquet.
            ConvertedType is superseded by LogicalType.  This enum should not be extended.
            
            See LogicalTypes.md for conversion between ConvertedType and LogicalType.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.UTF8">
            <summary>
            a BYTE_ARRAY actually contains UTF8 encoded chars
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.MAP">
            <summary>
            a map is converted as an optional field containing a repeated key/value pair
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.MAP_KEY_VALUE">
            <summary>
            a key/value pair is converted into a group of two fields
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.LIST">
            <summary>
            a list is converted into an optional field containing a repeated field for its
            values
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.ENUM">
            <summary>
            an enum is converted into a binary field
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.DECIMAL">
            <summary>
            A decimal value.
            
            This may be used to annotate binary or fixed primitive types. The
            underlying byte array stores the unscaled value encoded as two's
            complement using big-endian byte order (the most significant byte is the
            zeroth element). The value of the decimal is the value * 10^{-scale}.
            
            This must be accompanied by a (maximum) precision and a scale in the
            SchemaElement. The precision specifies the number of digits in the decimal
            and the scale stores the location of the decimal point. For example 1.23
            would have precision 3 (3 total digits) and scale 2 (the decimal point is
            2 digits over).
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.DATE">
            <summary>
            A Date
            
            Stored as days since Unix epoch, encoded as the INT32 physical type.
            
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.TIME_MILLIS">
            <summary>
            A time
            
            The total number of milliseconds since midnight.  The value is stored
            as an INT32 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.TIME_MICROS">
            <summary>
            A time.
            
            The total number of microseconds since midnight.  The value is stored as
            an INT64 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.TIMESTAMP_MILLIS">
            <summary>
            A date/time combination
            
            Date and time recorded as milliseconds since the Unix epoch.  Recorded as
            a physical type of INT64.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.TIMESTAMP_MICROS">
            <summary>
            A date/time combination
            
            Date and time recorded as microseconds since the Unix epoch.  The value is
            stored as an INT64 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.UINT_8">
            <summary>
            An unsigned integer value.
            
            The number describes the maximum number of meaningful data bits in
            the stored value. 8, 16 and 32 bit values are stored using the
            INT32 physical type.  64 bit values are stored using the INT64
            physical type.
            
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.INT_8">
            <summary>
            A signed integer value.
            
            The number describes the maximum number of meaningful data bits in
            the stored value. 8, 16 and 32 bit values are stored using the
            INT32 physical type.  64 bit values are stored using the INT64
            physical type.
            
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.JSON">
            <summary>
            An embedded JSON document
            
            A JSON document embedded within a single UTF8 column.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.BSON">
            <summary>
            An embedded BSON document
            
            A BSON document embedded within a single BINARY column.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.INTERVAL">
            <summary>
            An interval of time
            
            This type annotates data stored as a FIXED_LEN_BYTE_ARRAY of length 12
            This data is composed of three separate little endian unsigned
            integers.  Each stores a component of a duration of time.  The first
            integer identifies the number of months associated with the duration,
            the second identifies the number of days associated with the duration
            and the third identifies the number of milliseconds associated with
            the provided duration.  This duration of time is independent of any
            particular timezone or date.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.DataPageHeader">
            <summary>
            Data page header
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Num_values">
            <summary>
            Number of values, including NULLs, in this data page. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Encoding">
            <summary>
            Encoding used for this data page *
            
            <seealso cref="T:Parquet.Thrift.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Definition_level_encoding">
            <summary>
            Encoding used for definition levels *
            
            <seealso cref="T:Parquet.Thrift.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Repetition_level_encoding">
            <summary>
            Encoding used for repetition levels *
            
            <seealso cref="T:Parquet.Thrift.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Statistics">
            <summary>
            Optional statistics for the data in this page*
            </summary>
        </member>
        <member name="T:Parquet.Thrift.DataPageHeaderV2">
            <summary>
            New page format allowing reading levels without decompressing the data
            Repetition and definition levels are uncompressed
            The remaining section containing the data is compressed if is_compressed is true
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Num_values">
            <summary>
            Number of values, including NULLs, in this data page. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Num_nulls">
            <summary>
            Number of NULL values, in this data page.
            Number of non-null = num_values - num_nulls which is also the number of values in the data section *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Num_rows">
            <summary>
            Number of rows in this data page. which means pages change on record boundaries (r = 0) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Encoding">
            <summary>
            Encoding used for data in this page *
            
            <seealso cref="T:Parquet.Thrift.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Definition_levels_byte_length">
            <summary>
            length of the definition levels
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Repetition_levels_byte_length">
            <summary>
            length of the repetition levels
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Is_compressed">
            <summary>
            whether the values are compressed.
            Which means the section of the page between
            definition_levels_byte_length + repetition_levels_byte_length + 1 and compressed_page_size (included)
            is compressed with the compression_codec.
            If missing it is considered compressed
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Statistics">
            <summary>
            optional statistics for the data in this page *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.DecimalType">
            <summary>
            Decimal logical type annotation
            
            To maintain forward-compatibility in v1, implementations using this logical
            type must also set scale and precision on the annotated SchemaElement.
            
            Allowed for physical types: INT32, INT64, FIXED, and BINARY
            </summary>
        </member>
        <member name="T:Parquet.Thrift.DictionaryPageHeader">
            <summary>
            The dictionary page must be placed at the first position of the column chunk
            if it is partly or completely dictionary encoded. At most one dictionary page
            can be placed in a column chunk.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DictionaryPageHeader.Num_values">
            <summary>
            Number of values in the dictionary *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DictionaryPageHeader.Encoding">
            <summary>
            Encoding using this dictionary page *
            
            <seealso cref="T:Parquet.Thrift.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DictionaryPageHeader.Is_sorted">
            <summary>
            If true, the entries in the dictionary are sorted in ascending order *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.Encoding">
            <summary>
            Encodings supported by Parquet.  Not all encodings are valid for all types.  These
            enums are also used to specify the encoding of definition and repetition levels.
            See the accompanying doc for the details of the more complicated encodings.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.PLAIN">
            <summary>
            Default encoding.
            BOOLEAN - 1 bit per value. 0 is false; 1 is true.
            INT32 - 4 bytes per value.  Stored as little-endian.
            INT64 - 8 bytes per value.  Stored as little-endian.
            FLOAT - 4 bytes per value.  IEEE. Stored as little-endian.
            DOUBLE - 8 bytes per value.  IEEE. Stored as little-endian.
            BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.
            FIXED_LEN_BYTE_ARRAY - Just the bytes.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.PLAIN_DICTIONARY">
            <summary>
            Deprecated: Dictionary encoding. The values in the dictionary are encoded in the
            plain type.
            in a data page use RLE_DICTIONARY instead.
            in a Dictionary page use PLAIN instead
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.RLE">
            <summary>
            Group packed run length encoding. Usable for definition/repetition levels
            encoding and Booleans (on one bit: 0 is false; 1 is true.)
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.BIT_PACKED">
            <summary>
            Bit packed encoding.  This can only be used if the data has a known max
            width.  Usable for definition/repetition levels encoding.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.DELTA_BINARY_PACKED">
            <summary>
            Delta encoding for integers. This can be used for int columns and works best
            on sorted data
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.DELTA_LENGTH_BYTE_ARRAY">
            <summary>
            Encoding for byte arrays to separate the length values and the data. The lengths
            are encoded using DELTA_BINARY_PACKED
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.DELTA_BYTE_ARRAY">
            <summary>
            Incremental-encoded byte array. Prefix lengths are encoded using DELTA_BINARY_PACKED.
            Suffixes are stored as delta length byte arrays.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.RLE_DICTIONARY">
            <summary>
            Dictionary encoding: the ids are encoded using the RLE encoding
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.BYTE_STREAM_SPLIT">
            <summary>
            Encoding for floating-point data.
            K byte-streams are created where K is the size in bytes of the data type.
            The individual bytes of an FP value are scattered to the corresponding stream and
            the streams are concatenated.
            This itself does not reduce the size of the data but can lead to better compression
            afterwards.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.EncryptionWithColumnKey.Path_in_schema">
            <summary>
            Column path in schema *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.EncryptionWithColumnKey.Key_metadata">
            <summary>
            Retrieval metadata of column encryption key *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.FieldRepetitionType">
            <summary>
            Representation of Schemas
            </summary>
        </member>
        <member name="F:Parquet.Thrift.FieldRepetitionType.REQUIRED">
            <summary>
            This field is required (can not be null) and each record has exactly 1 value.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.FieldRepetitionType.OPTIONAL">
            <summary>
            The field is optional (can be null) and each record has 0 or 1 values.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.FieldRepetitionType.REPEATED">
            <summary>
            The field is repeated and can contain 0 or more values
            </summary>
        </member>
        <member name="T:Parquet.Thrift.FileCryptoMetaData">
            <summary>
            Crypto metadata for files with encrypted footer *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileCryptoMetaData.Encryption_algorithm">
            <summary>
            Encryption algorithm. This field is only used for files
            with encrypted footer. Files with plaintext footer store algorithm id
            inside footer (FileMetaData structure).
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileCryptoMetaData.Key_metadata">
            <summary>
            Retrieval metadata of key used for encryption of footer,
            and (possibly) columns *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.FileMetaData">
            <summary>
            Description for file metadata
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Version">
            <summary>
            Version of this file *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Schema">
            <summary>
            Parquet schema for this file.  This schema contains metadata for all the columns.
            The schema is represented as a tree with a single root.  The nodes of the tree
            are flattened to a list by doing a depth-first traversal.
            The column metadata contains the path in the schema for that column which can be
            used to map columns to nodes in the schema.
            The first element is the root *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Num_rows">
            <summary>
            Number of rows in this file *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Row_groups">
            <summary>
            Row groups in this file *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Key_value_metadata">
            <summary>
            Optional key/value metadata *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Created_by">
            <summary>
            String for application that wrote this file.  This should be in the format
            &lt;Application&gt; version &lt;App Version&gt; (build &lt;App Build Hash&gt;).
            e.g. impala version 1.0 (build 6cf94d29b2b7115df4de2c06e2ab4326d721eb55)
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Column_orders">
            <summary>
            Sort order used for the min_value and max_value fields in the Statistics
            objects and the min_values and max_values fields in the ColumnIndex
            objects of each column in this file. Sort orders are listed in the order
            matching the columns in the schema. The indexes are not necessary the same
            though, because only leaf nodes of the schema are represented in the list
            of sort orders.
            
            Without column_orders, the meaning of the min_value and max_value fields
            in the Statistics object and the ColumnIndex object is undefined. To ensure
            well-defined behaviour, if these fields are written to a Parquet file,
            column_orders must be written as well.
            
            The obsolete min and max fields in the Statistics object are always sorted
            by signed comparison regardless of column_orders.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Encryption_algorithm">
            <summary>
            Encryption algorithm. This field is set only in encrypted files
            with plaintext footer. Files with encrypted footer store algorithm id
            in FileCryptoMetaData structure.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Footer_signing_key_metadata">
            <summary>
            Retrieval metadata of key used for signing the footer.
            Used only in encrypted files with plaintext footer.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.IntType">
            <summary>
            Integer logical type annotation
            
            bitWidth must be 8, 16, 32, or 64.
            
            Allowed for physical types: INT32, INT64
            </summary>
        </member>
        <member name="T:Parquet.Thrift.JsonType">
            <summary>
            Embedded JSON logical type annotation
            
            Allowed for physical types: BINARY
            </summary>
        </member>
        <member name="T:Parquet.Thrift.KeyValue">
            <summary>
            Wrapper struct to store key values
            </summary>
        </member>
        <member name="T:Parquet.Thrift.LogicalType">
            <summary>
            LogicalType annotations to replace ConvertedType.
            
            To maintain compatibility, implementations using LogicalType for a
            SchemaElement must also set the corresponding ConvertedType (if any)
            from the following table.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.MilliSeconds">
            <summary>
            Time units for logical types
            </summary>
        </member>
        <member name="T:Parquet.Thrift.NullType">
            <summary>
            Logical type to annotate a column that is always null.
            
            Sometimes when discovering the schema of existing data, values are always
            null and the physical type can't be determined. This annotation signals
            the case where the physical type was guessed from all null values.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.OffsetIndex.Page_locations">
            <summary>
            PageLocations, ordered by increasing PageLocation.offset. It is required
            that page_locations[i].first_row_index &lt; page_locations[i+1].first_row_index.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.PageEncodingStats">
            <summary>
            statistics of a given page type and encoding
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageEncodingStats.Page_type">
            <summary>
            the page type (data/dic/...) *
            
            <seealso cref="T:Parquet.Thrift.PageType"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageEncodingStats.Encoding">
            <summary>
            encoding of the page *
            
            <seealso cref="T:Parquet.Thrift.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageEncodingStats.Count">
            <summary>
            number of pages of this type with this encoding *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageHeader.Type">
            <summary>
            the type of the page: indicates which of the *_header fields is set *
            
            <seealso cref="T:Parquet.Thrift.PageType"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageHeader.Uncompressed_page_size">
            <summary>
            Uncompressed page size in bytes (not including this header) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageHeader.Compressed_page_size">
            <summary>
            Compressed (and potentially encrypted) page size in bytes, not including this header *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageHeader.Crc">
            <summary>
            The 32bit CRC for the page, to be be calculated as follows:
            - Using the standard CRC32 algorithm
            - On the data only, i.e. this header should not be included. 'Data'
              hereby refers to the concatenation of the repetition levels, the
              definition levels and the column value, in this exact order.
            - On the encoded versions of the repetition levels, definition levels and
              column values
            - On the compressed versions of the repetition levels, definition levels
              and column values where possible;
              - For v1 data pages, the repetition levels, definition levels and column
                values are always compressed together. If a compression scheme is
                specified, the CRC shall be calculated on the compressed version of
                this concatenation. If no compression scheme is specified, the CRC
                shall be calculated on the uncompressed version of this concatenation.
              - For v2 data pages, the repetition levels and definition levels are
                handled separately from the data and are never compressed (only
                encoded). If a compression scheme is specified, the CRC shall be
                calculated on the concatenation of the uncompressed repetition levels,
                uncompressed definition levels and the compressed column values.
                If no compression scheme is specified, the CRC shall be calculated on
                the uncompressed concatenation.
            - In encrypted columns, CRC is calculated after page encryption; the
              encryption itself is performed after page compression (if compressed)
            If enabled, this allows for disabling checksumming in HDFS if only a few
            pages need to be read.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageLocation.Offset">
            <summary>
            Offset of the page in the file *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageLocation.Compressed_page_size">
            <summary>
            Size of the page, including header. Sum of compressed_page_size and header
            length
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageLocation.First_row_index">
            <summary>
            Index within the RowGroup of the first row of the page; this means pages
            change on record boundaries (r = 0).
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Columns">
            <summary>
            Metadata for each column chunk in this row group.
            This list must have the same order as the SchemaElement list in FileMetaData.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Total_byte_size">
            <summary>
            Total byte size of all the uncompressed column data in this row group *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Num_rows">
            <summary>
            Number of rows in this row group *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Sorting_columns">
            <summary>
            If set, specifies a sort ordering of the rows in this RowGroup.
            The sorting columns can be a subset of all the columns.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.File_offset">
            <summary>
            Byte offset from beginning of file to first page (data or dictionary)
            in this row group *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Total_compressed_size">
            <summary>
            Total byte size of all compressed (and potentially encrypted) column data
            in this row group *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Ordinal">
            <summary>
            Row group ordinal in the file *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.SchemaElement">
            <summary>
            Represents a element inside a schema definition.
             - if it is a group (inner node) then type is undefined and num_children is defined
             - if it is a primitive type (leaf) then type is defined and num_children is undefined
            the nodes are listed in depth first traversal order.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Type">
            <summary>
            Data type for this field. Not set if the current element is a non-leaf node
            
            <seealso cref="T:Parquet.Thrift.Type"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Type_length">
            <summary>
            If type is FIXED_LEN_BYTE_ARRAY, this is the byte length of the vales.
            Otherwise, if specified, this is the maximum bit length to store any of the values.
            (e.g. a low cardinality INT col could have this set to 3).  Note that this is
            in the schema, and therefore fixed for the entire file.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Repetition_type">
            <summary>
            repetition of the field. The root of the schema does not have a repetition_type.
            All other nodes must have one
            
            <seealso cref="T:Parquet.Thrift.FieldRepetitionType"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Name">
            <summary>
            Name of the field in the schema
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Num_children">
            <summary>
            Nested fields.  Since thrift does not support nested fields,
            the nesting is flattened to a single list by a depth-first traversal.
            The children count is used to construct the nested relationship.
            This field is not set when the element is a primitive type
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Converted_type">
            <summary>
            DEPRECATED: When the schema is the result of a conversion from another model.
            Used to record the original type to help with cross conversion.
            
            This is superseded by logicalType.
            
            <seealso cref="T:Parquet.Thrift.ConvertedType"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Scale">
            <summary>
            DEPRECATED: Used when this column contains decimal data.
            See the DECIMAL converted type for more details.
            
            This is superseded by using the DecimalType annotation in logicalType.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Field_id">
            <summary>
            When the original schema supports field ids, this will save the
            original field id in the parquet schema
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.LogicalType">
            <summary>
            The logical type of this SchemaElement
            
            LogicalType replaces ConvertedType, but ConvertedType is still required
            for some logical types to ensure forward-compatibility in format v1.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.SortingColumn">
            <summary>
            Wrapper struct to specify sort order
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SortingColumn.Column_idx">
            <summary>
            The column index (in this row group) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SortingColumn.Descending">
            <summary>
            If true, indicates this column is sorted in descending order. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SortingColumn.Nulls_first">
            <summary>
            If true, nulls will come before non-null values, otherwise,
            nulls go at the end.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.SplitBlockAlgorithm">
            <summary>
            Block-based algorithm type annotation. *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.Statistics">
            <summary>
            Statistics per row group and per page
            All fields are optional.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.Statistics.Max">
            <summary>
            DEPRECATED: min and max value of the column. Use min_value and max_value.
            
            Values are encoded using PLAIN encoding, except that variable-length byte
            arrays do not include a length prefix.
            
            These fields encode min and max values determined by signed comparison
            only. New files should use the correct order for a column's logical type
            and store the values in the min_value and max_value fields.
            
            To support older readers, these may be set when the column order is
            signed.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.Statistics.Null_count">
            <summary>
            count of null value in the column
            </summary>
        </member>
        <member name="P:Parquet.Thrift.Statistics.Distinct_count">
            <summary>
            count of distinct values occurring
            </summary>
        </member>
        <member name="P:Parquet.Thrift.Statistics.Max_value">
            <summary>
            Min and max values for the column, determined by its ColumnOrder.
            
            Values are encoded using PLAIN encoding, except that variable-length byte
            arrays do not include a length prefix.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.StringType">
            <summary>
            Empty structs to use as logical type annotations
            </summary>
        </member>
        <member name="T:Parquet.Thrift.TimestampType">
            <summary>
            Timestamp logical type annotation
            
            Allowed for physical types: INT64
            </summary>
        </member>
        <member name="T:Parquet.Thrift.TimeType">
            <summary>
            Time logical type annotation
            
            Allowed for physical types: INT32 (millis), INT64 (micros, nanos)
            </summary>
        </member>
        <member name="T:Parquet.Thrift.Type">
            <summary>
            Types supported by Parquet.  These types are intended to be used in combination
            with the encodings to control the on disk storage format.
            For example INT16 is not included as a type since a good encoding of INT32
            would handle this.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.TypeDefinedOrder">
            <summary>
            Empty struct to signal the order defined by the physical or logical type
            </summary>
        </member>
        <member name="T:Parquet.Thrift.Uncompressed">
            <summary>
            The compression used in the Bloom filter.
            
            </summary>
        </member>
        <member name="T:Parquet.Thrift.XxHash">
            <summary>
            Hash strategy type annotation. xxHash is an extremely fast non-cryptographic hash
            algorithm. It uses 64 bits version of xxHash.
            
            </summary>
        </member>
    </members>
</doc>
